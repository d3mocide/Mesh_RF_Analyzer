// Worker.ts
// Web Worker for MeshRF Engine

// Import the Emscripten factory (generated by Emcc with -sMODULARIZE=1)
// @ts-ignore: meshrf.js is generated
import createMeshRF from './meshrf.js';  

// Types for Emscripten Module
interface MeshRFModule {
    HEAPF32: Float32Array;
    HEAPU8: Uint8Array;
    _malloc(size: number): number;
    _free(ptr: number): void;
    
    // Bindings
    calculate_itm(profile_ptr: number, count: number, params: any): any; // Returns VectorFloat (needs .size(), .get())
    calculate_viewshed(elev_ptr: number, width: number, height: number, tx_x: number, tx_y: number, tx_h: number, max_dist: number): any; // Returns VectorUint8
    optimize_site_selection(matrix_ptr: number, num_candidates: number, num_targets: number): any; // Returns VectorInt
    
    LinkParameters: any;
    VectorFloat: any;
    VectorUint8: any; // Fix missing definition
    VectorInt: any;   // New Vector type
}

let module: MeshRFModule | null = null;

// Initialize Wasm Module
createMeshRF().then((m: any) => {
    module = m;
    postMessage({ type: 'INIT_COMPLETE' });
});

self.onmessage = (e: MessageEvent) => {
    if (!module) {
        console.error("MeshRF Module not initialized");
        return;
    }

    const { id, type, payload } = e.data;
    console.log(`[Worker] Received message: ${type} (ID: ${id})`);

    try {
        if (type === 'CALCULATE_ITM') {
            handleITM(id, payload);
        } else if (type === 'CALCULATE_VIEWSHED') {
            handleViewshed(id, payload);
        } else if (type === 'CALCULATE_OPTIMIZATION') {
            handleOptimization(id, payload);
        }
    } catch (err: any) {
        postMessage({ id, error: err.toString() });
    }
};

function handleITM(id: string, payload: any) {
    if (!module) return;

    const { profile, params } = payload; // profile is Float32Array
    
    // 1. Allocate Memory
    const byteSize = profile.length * 4;
    const ptr = module._malloc(byteSize);
    
    try {
        // 2. Copy Data to heap
        // module.HEAPF32 is a live view, need to account for pointer offset (ptr / 4)
        module.HEAPF32.set(profile, ptr / 4);
        
        // 3. Call C++
        // Construct LinkParameters object
        // Assuming params matches struct fields. 
        // Embind objects can be passed as JS objects if registered as value_object.
        
        const resultVec = module.calculate_itm(ptr, profile.length, params);
        
        // 4. Copy Result back
        // resultVec is a VectorFloat (C++ object). 
        // Need to convert to Float32Array.
        const size = resultVec.size();
        const resultArr = new Float32Array(size);
        for (let i = 0; i < size; i++) {
            resultArr[i] = resultVec.get(i);
        }
        
        // Cleanup Vector
        resultVec.delete();

        // 5. Return
        postMessage({ id, type: 'CALCULATE_ITM_RESULT', result: resultArr }, [resultArr.buffer]);

    } finally {
        module._free(ptr);
    }
}

function handleViewshed(id: string, payload: any) {
    if (!module) return;

    const { elevation, width, height, tx_x, tx_y, tx_h, max_dist } = payload;
    
    // elevation is Float32Array
    const byteSize = elevation.length * 4;
    console.log(`[Worker] Allocating ${byteSize} bytes for viewshed`);
    const ptr = module._malloc(byteSize);

    try {
        console.log(`[Worker] Setting HEAPF32 data`);
        module.HEAPF32.set(elevation, ptr / 4);

        console.log(`[Worker] Calling C++ calculate_viewshed with w=${width}, h=${height}, tx=(${tx_x},${tx_y}), dist=${max_dist}`);
        const resultVec = module.calculate_viewshed(ptr, width, height, tx_x, tx_y, tx_h, max_dist);
        console.log(`[Worker] C++ returned resultVec. Size: ${resultVec.size()}`);
        
        const size = resultVec.size();
        const resultArr = new Uint8Array(size);
        for (let i = 0; i < size; i++) {
            resultArr[i] = resultVec.get(i);
        }
        
        resultVec.delete();
        
        console.log(`[Worker] Posting result back`);
        postMessage({ id, type: 'CALCULATE_VIEWSHED_RESULT', result: resultArr }, [resultArr.buffer]);

    } finally {
        module._free(ptr);
    }
}

function handleOptimization(id: string, payload: any) {
    if (!module) return;
    
    // Payload: coverageMatrix (Float32Array 0/1), numCandidates, numTargets
    const { coverageMatrix, numCandidates, numTargets } = payload;
    
    const byteSize = coverageMatrix.length * 4;
    const ptr = module._malloc(byteSize);
    
    try {
        module.HEAPF32.set(coverageMatrix, ptr / 4);
        
        const resultVec = module.optimize_site_selection(ptr, numCandidates, numTargets);
        
        const size = resultVec.size();
        const resultArr = new Int32Array(size); // VectorInt maps to Int32
        for (let i = 0; i < size; i++) {
            resultArr[i] = resultVec.get(i);
        }
        
        resultVec.delete();
        
        // Return selected indices
        postMessage({ id, type: 'CALCULATE_OPTIMIZATION_RESULT', result: resultArr });
        
    } finally {
        module._free(ptr);
    }
}
